<!--
Sync Impact Report - 憲章更新影響報告
==============================================
版本變更: [初始化] → 1.0.0
變更類型: MAJOR - 初始版本建立

新增原則:
  ✅ I. 領域驅動設計 (DDD)
  ✅ II. CQRS 模式
  ✅ III. SOLID 原則
  ✅ IV. 測試驅動開發 (TDD)
  ✅ V. 簡單至上 (KISS)
  ✅ VI. 例外處理策略
  ✅ VII. 繁體中文文件與溝通
  ✅ VIII. 程式碼註解規範

新增章節:
  ✅ 開發流程規範
  ✅ 專案結構要求
  ✅ 治理規則

模板一致性檢查:
  ✅ plan-template.md - 已更新 Constitution Check 章節,反映所有憲章原則
  ✅ tasks-template.md - 已更新任務格式,加入建置與測試狀態標註要求
  ✅ spec-template.md - 無需更新 (已符合憲章要求,使用繁體中文)
  ✅ checklist-template.md - 無需更新 (通用模板,不涉及憲章原則)
  ✅ agent-file-template.md - 無需更新 (通用模板,不涉及憲章原則)

後續待辦事項:
  - 建議進行程式碼審查,確認現有程式碼符合所有憲章原則
  - 考慮為現有程式碼補充 XML 註解與 inline comment
  - 檢查現有測試覆蓋率是否達到 80% 目標
-->

# ReleaseSync 專案憲章

## 核心原則

### I. 領域驅動設計 (DDD)

專案必須遵循領域驅動設計 (Domain-Driven Design) 的戰術模式:

- **實體 (Entity)** 與 **值物件 (Value Object)** 必須明確區分
- **聚合 (Aggregate)** 邊界必須清晰定義,確保業務規則的一致性
- **領域服務 (Domain Service)** 用於處理跨實體的業務邏輯
- **Repository 模式** 用於資料存取抽象化
- 核心業務邏輯必須位於 Domain 層,不得依賴基礎設施層

**理由**: DDD 確保業務邏輯的清晰表達,降低複雜度,提高可維護性。透過戰術模式的應用,團隊能夠建立與業務語言一致的程式碼模型。

### II. CQRS 模式

命令查詢職責分離 (Command Query Responsibility Segregation) 必須在適當場景下應用:

- **命令 (Command)** 負責狀態變更,不返回資料
- **查詢 (Query)** 負責資料讀取,不變更狀態
- 複雜查詢可繞過領域模型直接存取資料層,以提升效能
- 命令與查詢的處理器 (Handler) 必須明確分離

**理由**: CQRS 分離讀寫職責,簡化複雜業務邏輯,提升系統可擴展性與效能。讀取與寫入的最佳化策略不同,分離後可各自最佳化。

### III. SOLID 原則

所有程式碼必須遵循 SOLID 設計原則:

- **單一職責原則 (SRP)**: 每個類別只有一個變更理由
- **開放封閉原則 (OCP)**: 對擴展開放,對修改封閉
- **里氏替換原則 (LSP)**: 子類別必須能替換父類別
- **介面隔離原則 (ISP)**: 不應強迫實作不使用的介面
- **依賴反轉原則 (DIP)**: 依賴抽象而非具體實作

**理由**: SOLID 原則是物件導向設計的基石,確保程式碼的可維護性、可測試性與可擴展性。違反 SOLID 原則會導致程式碼僵化、脆弱且難以重用。

### IV. 測試驅動開發 (TDD) - 強制執行

測試驅動開發為**不可妥協**的開發實踐:

- **先寫測試**: 實作任何功能前必須先撰寫失敗的測試
- **紅燈-綠燈-重構循環**: 嚴格遵循 Red-Green-Refactor 循環
- **使用者審核**: 測試撰寫完成後必須經使用者審核才能進行實作
- **單元測試覆蓋率**: 核心業務邏輯必須達到 80% 以上覆蓋率
- **整合測試**: 新增或變更契約、跨服務溝通、共用 Schema 時必須撰寫整合測試

**理由**: TDD 確保程式碼的正確性、可測試性與設計品質。先寫測試迫使開發者思考介面設計與使用情境,避免過度設計與未來的技術債。

### V. 簡單至上 (KISS)

保持程式碼簡單,避免過度設計:

- **YAGNI 原則**: You Aren't Gonna Need It - 不實作當前不需要的功能
- **最小可行實作**: 優先選擇最簡單且能解決問題的方案
- **避免過早最佳化**: 先確保功能正確,再進行效能調校
- **清晰勝於聰明**: 易讀的程式碼優於炫技的程式碼

**理由**: 複雜度是軟體專案的最大敵人。簡單的設計更容易理解、測試、維護與擴展。過度設計會增加認知負擔與維護成本。

### VI. 例外處理策略

例外處理必須有明確的目的與策略:

- **按需捕捉**: 僅在需求明確要求時才使用 try-catch 捕捉例外
- **不吞例外**: 捕捉例外後必須進行有意義的處理,不得靜默忽略
- **例外類型**: 使用自訂例外類型表達領域錯誤,而非依賴系統例外
- **記錄與傳播**: 例外必須記錄詳細資訊,並在適當層級處理或向上傳播
- **失敗快速**: 在不可恢復的錯誤情況下,盡早失敗而非嘗試修復

**理由**: 過度使用 try-catch 會掩蓋真正的問題,導致錯誤被靜默忽略。例外處理應該是有意識的決策,而非預設行為。

### VII. 繁體中文文件與溝通

所有文件與溝通必須使用繁體中文 (zh-TW):

- **程式碼註解**: 所有 XML 註解與 inline comment 必須使用繁體中文
- **文件檔案**: README、規格文件、技術文件等必須使用繁體中文
- **Git 訊息**: Commit message 可使用英文簡要描述,但詳細說明建議使用繁體中文
- **使用者介面**: 所有面向使用者的訊息必須使用繁體中文
- **團隊溝通**: 所有內部溝通 (Issue、PR、討論) 使用繁體中文

**理由**: 統一的語言降低溝通成本,提升團隊協作效率。繁體中文確保所有團隊成員能夠準確理解業務需求與技術細節。

### VIII. 程式碼註解規範

程式碼必須包含適當且有意義的註解:

- **XML 註解**: 所有公開的類別、介面、方法、屬性必須包含 `<summary>` XML 註解
- **參數說明**: 複雜方法必須包含 `<param>` 與 `<returns>` 說明
- **Inline Comment**: 複雜邏輯、重要決策、非直覺的實作必須包含 inline comment
- **註解品質**: 註解應說明「為什麼」而非「做什麼」,程式碼本身應該足夠清晰表達「做什麼」
- **保持同步**: 程式碼變更時必須同步更新相關註解

**理由**: 良好的註解是程式碼可維護性的關鍵。XML 註解提供 IDE 智慧提示,inline comment 協助未來的維護者理解設計決策。

## 開發流程規範

### Plan 階段

在執行 `/speckit.plan` 命令時,必須遵循以下流程:

- **重用優先**: 優先搜尋並重複使用現有的邏輯與元件
- **避免重複**: 發現相似功能時,應評估重構或擴展現有元件而非建立新元件
- **相依性分析**: 清楚識別新功能對現有元件的相依性
- **設計驗證**: 設計方案必須符合所有核心原則 (DDD, CQRS, SOLID, TDD, KISS)

### Task 階段

在執行 `/speckit.tasks` 或 `/speckit.implement` 命令時,每個階段性任務必須標註:

- **建置狀態**: 階段性任務完成後,程式碼是否可以成功建置
- **測試狀態**: 階段性任務完成後,所有單元測試是否會通過
- **整合影響**: 是否影響現有整合測試,是否需要新增整合測試
- **回滾計畫**: 如任務失敗,如何回滾到穩定狀態

## 專案結構要求

### Program.cs 最小化

`Program.cs` 必須保持簡潔,僅負責:

- **應用程式啟動**: 建立與啟動主機 (Host)
- **相依性注入**: 註冊服務到 DI 容器
- **組態載入**: 載入與綁定組態設定
- **禁止事項**: 不得包含業務邏輯、複雜的初始化流程、錯誤處理邏輯

**實踐指引**:
- 複雜的服務註冊邏輯應抽取到擴展方法 (如 `AddApplicationServices()`)
- 初始化邏輯應移至專屬的啟動服務或 Hosted Service
- 保持 `Program.cs` 在 50 行程式碼以內為目標

### 分層架構

專案必須遵循清晰的分層架構:

```
Domain Layer (核心層)
  ↑ 不依賴任何其他層
Application Layer (應用層)
  ↓ 依賴 Domain Layer
Infrastructure Layer (基礎設施層)
  ↓ 依賴 Domain Layer 與 Application Layer
Presentation Layer (表示層 - Console, API)
  ↓ 依賴 Application Layer
```

**相依性規則**:
- Domain Layer 不得依賴任何其他層
- Application Layer 透過介面依賴基礎設施,不得直接依賴具體實作
- Infrastructure Layer 實作 Domain 與 Application 定義的介面

## 治理規則

### 憲章優先

本憲章優先於所有其他實踐與慣例:

- 所有 Pull Request 必須驗證是否符合憲章原則
- Code Review 必須檢查 SOLID、TDD、註解規範的遵循情況
- 違反憲章的程式碼不得合併,除非有明確的例外批准

### 修正程序

憲章的修正必須經過以下程序:

- **提案**: 提出修正提案,說明修正理由與影響範圍
- **審核**: 團隊審核提案,評估對現有程式碼與流程的影響
- **批准**: 需獲得團隊共識才能批准修正
- **遷移計畫**: 批准後必須制定遷移計畫,更新受影響的程式碼與文件
- **版本控制**: 修正後必須更新憲章版本號

### 複雜度管理

所有增加複雜度的決策必須有充分理由:

- **技術選型**: 引入新技術或框架前必須評估學習成本與長期維護成本
- **模式應用**: 設計模式的應用必須有明確的問題要解決,而非為了模式而模式
- **抽象層級**: 抽象必須有實際價值,過度抽象會降低可讀性

### 執行時期開發指引

本專案使用 `.specify/` 目錄管理開發流程與規範:

- **憲章檔案**: `.specify/memory/constitution.md` (本檔案)
- **模板檔案**: `.specify/templates/` 包含各類文件模板
- **命令檔案**: `.specify/templates/commands/` 包含 SpecKit 命令定義

所有開發活動必須遵循本憲章定義的原則與流程。

**版本**: 1.0.0 | **批准日期**: 2025-11-08 | **最後修正**: 2025-11-08
